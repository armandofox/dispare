#!/bin/csh -f
#  Shell script to generate FooEvent_Event.p from event.p.skel
#  Usage: xevent evtskel alleventsfile thiseventname
#	 statestructname usercode formalparms inputstructs
#	evtskel: the skeleton file 
#	alleventsfile: a file containing the names of each event type
#	thiseventname: name of this event type
#	usercode: file containing user code for this event
#	formalparms: file cont. user's formal parameter names for inputs
#	inputstructs: the .inp file generated by build script

set evtskel=$1
set alleventsfile=$2
set thiseventname=$3
set usercode=$4
set newusercode=$4.cpp
set formalparms=$5
set inputstructs=$6

# set index for this event type; 0<=eventIndex<=numEvents-1
set thiseventnum=`awk '/'$thiseventname'/ { print NR-1 }' $alleventsfile`
set statestructname=`awk 'NR == '$thiseventnum'+1 { print $2 }' $alleventsfile`
# determine #events and #inputs
set numevents=`awk 'END { print NR }' $alleventsfile`
set numinputs=`awk 'END { print NR }' $formalparms`

# preprocess user code: run through C preprocessor and substitute where
# event-scheduling calls appear
cp $usercode $usercode.c
cc -E $usercode.c | \
sed '1d' | \
nawk    'NR <= '$numevents' { evtname[NR] = $1 } \
	NR > '$numevents' { print } \
       	/SCHEDULE/  { 	for (i=1; i<='$numevents'; i++) { \
		   q=index($0,evtname[i]) \
                   if (q != 0) {  \
			q1=index($0,"(")  \
			split(substr($0,q1+1,length($0)-q1),arg,":")  \
			link=arg[1]  \
			colon=index($0,":")  \
			split(substr($0,colon+1,length($0)-colon),arg2,",") \
			j=arg2[1]  \
			split(arg2[2],arg3,")")  \
			time=arg3[1]  \
     print "\t" evtname[i] "_New=(" evtname[i] "_New_Msg *)CkAllocMsg(sizeof(" evtname[i] "_New_Msg));"  \
     print "\t" evtname[i] "_New->input.I" j "=" link ";"  \
     print "\t" evtname[i] "_New->which_input=" j-1 ";"  \
     print "\t" evtname[i] "_New->sched_timestep=" time ";"  \
     print "\tSendMsg(S_" evtname[i] "@NEW_EVENT," evtname[i] "_New,&(" evtname[i] "_StateCID));"  \
	} } }  \
' $alleventsfile - | \
sed '/SCHEDULE/d' \
>$newusercode
rm $usercode.c

cat $evtskel | \
sed	"s/#STATESTRUCT#/$statestructname/g" | \
sed 	"s/#EVENT#/$thiseventname/g" | \
sed	"s/#MYINDEX#/$thiseventnum/g" | \
sed	"/#USERS_CODE#/r $newusercode" | \
nawk    'NR <= '$numevents'  { evtname[NR] = $1 } \
	NR > '$numevents'  { print } \
	/#CHILDCIDS#/  { for (i=1; i<='$numevents'; i++) { \
			s = "\tChareIDType " evtname[i]  "_StateCID;" \
			print s } } \
	/#INITCHILDCIDS#/ { for (i=1; i<='$numevents'; i++)  \
	     print "\t" evtname[i] "_StateCID=EInitMsg->AllCID[" i-1 "];" } \
	/#NEWEVENTMSG#/  { for (i=1; i<='$numevents'; i++)  \
		print "\t" evtname[i] "_New_Msg *" evtname[i] "_New;" }  \
	/#MSGSEQ#/	{ for (i=1; i<='$numevents'; i++)  \
		print "\tint " evtname[i] "_Seq;" } \
	/#INITMSGSEQ#/	{ for (i=1; i<='$numevents'; i++) \
		print "\t" evtname[i] "_Seq = 1;" } \
'  $alleventsfile - | \
nawk    'NR <= '$numinputs' { formal[NR] = $0 } \
	NR > '$numinputs' && NR <= 2*'$numinputs' { \
		 structtype[NR-'$numinputs'] = $1 } \
	NR > 2*'$numinputs' { print } \
	/#USERS_INPUTSTRUCTS#/ { for (i=1; i<='$numinputs'; i++) { \
		print "\t" structtype[i] "  " formal[i] ";" } }  \
	/#ASSIGN_INPUTS#/ { for (i=1; i<='$numinputs'; i++)  {  \
		print "\t" formal[i] " = eventINPUT->I" i ";" } }  \
' $formalparms $inputstructs -  \
>${thiseventname}_Event.p

rm $newusercode


	
