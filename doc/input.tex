\chapter{Using \dispare: User's View}
\label{input}

Using \dispare consists of four steps:
\begin{itemize}
\item prepare the input specification and event code files;
\item build the simulator code;
\item  compile the simulator code on the Chare Kernel;
\item  run the executable.
\end{itemize}
The sections below explain how to perform
each step, and describe the user's view of the \dispare simulation model.

%%======================================================================
\section{Simulation Model}

\subsection{Event Scheduling}

\dispare's simulation model allows the user to define any number of different
types of events.  Each event has one or more {\em inputs} and an
associated {\em state}.  Formally, an input to an event is an edge in an
event-instance dependency graph.  This implies that an event which has
multiple inputs receives each input from a different parent, or at least
from different parent instances.  

The inputs are data generated by other events and fed to this event.
The state can be any information the user wants to retain between
instances of the event; for example, in modeling a bank account, the
state might include the account balance and last transaction date, and
an input might be a deposit or withdrawal amount.  Note that the state
is the {\em only} way to maintain simulation information across event
instances; there are no other ``global'' variables.

\dispare schedules and simulates instances of the user
events.\footnote{Do not confuse the user's notion of an instance of an
event with the system's instance of a chare.  In \dispare, a new chare
is {\em not} created for each event instance, but rather one chare is
created for each event {\em type} and called repeatedly to simulate
successive instances of the event.  See chapter \ref{technical} for
details.}  An event instance occurs on a particular integer {\em timestep};
initially, one of each type of event is automatically scheduled for time
1.  The event simulation itself consists of user-supplied C code blocks
that perform whatever actions are appropriate to simulate the event; to
continue the bank account example, this might include subtracting the
withdrawal amount input from the account balance contained in the state
variable.  The event code can also schedule other events of any type,
specifying an input and when the event is to be performed.  The user's
event code has access to its inputs, its state, and the current timestep
(i.e. the time at which this event is executing); it can use this
information to schedule other events.  A complete example of a CPU
process queueing system is presented in chapter \ref{example}.


%%======================================================================
\section{The Specification File}

{\bf NOTE:}  In addition to the syntax described here, be sure to read
Chapter \ref{syntax}, which describes bugs and warnings that apply to the
prototype builder.

The specification file, whose name should end in {\tt .spc}, contains
declarations of the event types and the structures associated with the
event inputs and states.

\subsection{Input and State Structures}

The input and state structures are C {\tt typedef struct}'s.  The
components of the structure may be anything the user wants, except
pointers that point outside themselves.  Variable-sized structures are
not allowed.\footnote{These restrictions come from the fact that
pointers do not have the standard interpretation in many
parallel-processing environments, such as message passing
architectures.} Note that {\em all inputs must be distinct}, that is, if
a particular event type requires two inputs of identical structure, they
still must be declared as two different kinds of {\tt struct}s.  The
\dispare reserved word {\tt INPUT} or {\tt STATE} must appear
immediately after the structure declaration's closing brace, to identify
whether this structure identifies an input or a state.

The tagged-structure declarations should be at the beginning of the {\tt
.spc} file.  For example:

\begin{verbatim}
typedef struct {
	float WithdrawalAmount;
	int WhenPosted;
} INPUT Withdrawal;

typedef struct {
	float TransferAmount;
	int fromAcct,toAcct;
	int WhenPosted;
} INPUT AcctTransfer;

typedef struct {
	float CurrentBalance;
	int LastTransPosted;
	int LastTransMade;
} STATE AccountState;
\end{verbatim}

\subsection{Event Prototypes}

Event prototypes essentially look like C function prototypes with return
type {\tt EVENT}.  The prototype has $n$ arguments, corresponding to the
$n$ inputs expected by the event type.  The inputs must be tagged
structures defined as described above.  In addition, the prototype must
be followed by a colon and the tag of the state structure used for this
event.  In other words, the event prototype ties together the input
structure declarations, state structure declarations and event name.
For example:

\begin{verbatim}
EVENT DoWithdrawal(Withdrawal theWithdrawInput) : AccountState;
\end{verbatim}

\subsection{Limitations in Specification File}

{\tt \#include} directives are permitted in the specification file.

{\tt \#define} directives are permitted in the specification file, as
long as they don't conflict with \dispare's internal definitions (this
is unlikely).  Note that since the event code blocks must each reside in
a separate file (see below), separate {\tt \#define}s will have to appear
there to avoid conflicts---the event
code files can't {\tt \#include} the specification file.  This is not
elegant, and it is temporarily this way because it simplifies the
builder.
%%======================================================================
\section{Writing the Simulation Code}

\subsection{Accessing Inputs, State and Time Step}

The C code block which performs the simulation of an event looks like a
C function that returns no value.  Its event prototype is declared in the {\tt
.spc} file as described above.  The event code for each event type
should reside in a separate file whose name is {\em event}{\tt .evt},
where {\em event} is the user-defined name given in the event prototype.
In the example above, the code to simulate a {\tt DoWithdrawal} event
would be located in a file called {\tt DoWithdrawal.evt}.

Note that the contents of the {\tt .evt} file should consist {\bf only}
of a C code block with its delimiting braces; the {\tt .evt} files
should {\bf not} include the event prototype, or the \dispare builder
will get confused.

Since the inputs and state are user-defined structures, they may be accessed
as needed in the event code.  The event code does not need (and should
not try) to declare inputs explicitly; \dispare will make them available
automatically.  To access an input structure, simply refer
to it using the same identifier name as was given in the event prototype
(in the {\tt .spc} file).  

The code may also refer to {\tt TIME}, an integer whose value is the
timestep at which this event is executing, and {\tt STATE}, a state
structure for this event (as defined by the user) containing the current
state.  For example, in the bank account example above, the code would
be able to say something like:

\begin{verbatim}
	STATE.CurrentBalance -= theWithdrawalInput.WithdrawalAmount;
	STATE.LastTransPosted = theWithdrawalInput.WhenPosted;
	STATE.LastTransMade = TIME;
\end{verbatim}

Note that the identifiers {\tt STATE} and {\tt TIME} are  case sensitive
and reserved: the user may not declare local variables called {\tt
STATE} or {\tt TIME}. 

\subsection{Scheduling New Events}

The event code can provide an input for and schedule an instance of any
event type.  Note that there is exactly one kind of input that one event
type can provide to another; that is, if event type A's code schedules
instances of event type B, which takes three inputs, A always provides
the second input (for example).  It is illegal for A to provide the
first input to B under certain conditions but the second input under
different conditions.

To schedule a new event, a structure of the appropriate input type must
be declared as a local variable in the simulation code.  The simulation
code fills in the value of the input as desired, and schedules the event
as follows:

\begin{verbatim}
	SCHEDULE eventName(input:inputNum,schedTime);
\end{verbatim}

{\tt eventName} is the name of the event type of which an instance is
being scheduled, for example, {\tt DoWithdrawal} in the example above.
{\tt input} is the local variable whose type matches the type of the
input being supplied.  {\tt inputNum} should be an integer specifying
which input this corresponds to in the event prototype; for example, if
the input being supplied is the third argument in the event prototype,
{\tt inputNum} should be 3.  This step should really be done by the
builder, but for the current prototype builder implementation this
represented a significant complication.

 {\tt schedTime} is the timestep for which the new
event is to be scheduled; it must be the case that $schedTime>=TIME+1$
(since all timesteps are integers).  Although this currently isn't
enforced by \dispare, failure to heed this warning will result in
nonsensical output.

The word SCHEDULE is a reserved word; the user code may not include
local variables, etc. with this name.

{\bf NOTE:} The parameters to the event-scheduling call are manipulated
internally by \dispare, so don't use any expressions that may produce
side effects.  Also, no parenthesized expressions may appear inside the
event-scheduling call, due to the way the builder parses the call.

If an event has multiple inputs, scheduling calls to create an instance
of it will have to appear in more than one parent.  Suppose event type C
takes two inputs; the first supplied by A, the second by B.  It is
desired to schedule an instance of C.  To accomplish this, A and B each
schedule an instance of C {\em with the same timestep} in their
respective simulation code, and supply their respective inputs.
\dispare will take care of ``matching'' the inputs and providing them
both to the instance of C being scheduled.  Note that it is the fact
that both instances are scheduled for the same timestep that makes this
mechanism work.

It may seem limiting that both A and B have to ensure that they schedule
C for the same timestep, but in practice this is very simple.  Although
an event instance can't implicitly access the time step at which it was
originally created, the creator can encode this information in one of
the inputs.  This way event instances can use this information to
schedule new events; for example, even if A and B were executing at
different times, they might agree to schedule an instance of C at the
next integral timestep divisible by 10.  

\subsection{Initial Conditions}

Initially, \dispare schedules one of each type of event at time 1.  {\bf
The values of the inputs and state structures for this initial event are
undefined}, that is, they are not initialized by \dispare and may
contain ``garbage'' values.  For this reason, the event simulation code
should check whether its timestep is 1, and if so perform any necessary
initialization of the state variables and then schedule the first
``real'' event.  This limitation makes the builder {\em much} simpler
since it doesn't have to dig around to figure out the names of fields in
the various user-defined structures.

\subsection{Input and Output}

Inside the event code, the user can put {\tt CkPrintf} statements to
output information to the standard output stream.  The syntax and
prototype for {\tt CkPrintf} is exactly the same as for the C function
{\tt printf}.  

Files can be manipulated using Unix file idioms provided that a given
event instance opens the file, manipulates it and closes it.  This is
because there is no guarantee that the file pointers can be expected to
remain valid across event calls.

Since \dispare is a parallel system, event instances may occur in a
non-obvious sequence; therefore it will probably be helpful to include
in the {\tt CkPrintf} statement the timestep at which the event is
executing (assuming this is important to the user).

Similarly, the {\tt CkScanf} call can be used to read input from the
terminal during simulation; again, a helpful message indicating which
event instance is requesting the input is probably in order.

\subsection{Stopping the Simulation}

Normally, the simulation will run until all event types have passed a
simulation timestep specified on the command line (see the next
section).  However, the user can use the {\tt StopSim} call to indicate
that the simulation should stop at some other timestep, overriding the
value on the command line.  The syntax is
simply {\tt StopSim(}{\em ts}{\tt )}, where {\em ts} is an integer whose
value is the timestep at which simulation should stop.  This value is
broadcast to all the running processes; those which have already reached
this timestep will simply stop and ignore any remaining events in their
processing queues, and those which haven't will continue to run until
they reach this point or quiescence is detected by the Chare Kernel.
(The latter situation prevents a process from waiting indefinitely for
an input which will never arrive because the process that was supposed
to produce it was stopped by {\tt StopSim}.)

Any {\tt StopSim} calls  made after the first are ignored unless they
specify a stop time {\em earlier} than the time specified in the last
{\tt StopSim} call.  In this case, the new time will be broadcast to all
running processes; again, some of the processes may have already passed
this timestep, in which case they will stop upon receiving the stop
message.  Basically, due to the inherent asynchrony in the system, the
only guarantee which can be made of {\tt StopSim} is that it will cause
all processes to stop ``as soon as possible.''

A diagnostic message will be printed on the standard output whenever a
{\tt StopSim} call is acknowledged.

\subsection{Limitations in Event Code Blocks}

The event code must {\bf not} include any {\tt return} statements!  This
is because \dispare expects the user code to eventually ``fall through''
so it can do postprocessing.  Instead of {\tt return}, use explicit {\tt
if\ldots else} constructs to skip unwanted code.  In other words, the
code should be written so that a statement following the last line of
the code would always be executed.

Using pointers inside event code blocks is discouraged at best, for the
same reasons that pointers are not allowed inside state and input
structures.  In the current implementation of the Chare Kernel, it is
guaranteed that chares will not migrate once they are created, so in
theory it is possible for event code to perform dynamic memory
allocation (using the {\tt CkAlloc} system call) and maintain a pointer
to that memory in its state structure; however, in future version of the
Chare Kernel this may not be true.

As mentioned above, event code cannot contain static variables; use the
state structure to maintain information between event instances.

As with the specification file, {\tt \#define}s are permitted but {\tt
\#include}s are not.  The {\tt \#define}s must not conflict with those in
the specification file.
%%======================================================================
\section{Running the Builder}

To run the builder, the {\tt .spc} (specification) file and
an {\tt .evt} file for each event type must be present in the current
directory. 

Typing {\tt build} {\em specfile outfile}, where {\em specfile} is the name of
the specification file (without the {\tt .spc} extension), will use all
these files to generate a single source code file {\em outfile}{\tt .p}.
Currently the builder does no error checking is done, so errors in the
specification and code may not show up until the compile stage.

Note that at the moment, all of the \dispare files (including skeleton
files and builder scripts) and the {\tt .spc} and {\tt .evt} files must
be in the {\em same directory}, and the {\tt build} command must be
issued from that directory, or else the builder will be unable to find
the files.

%%======================================================================
\section{Compiling and Executing}

Once the builder has built the output file, it needs to be compiled into
a Chare Kernel executable.  A ``generic'' Makefile is supplied in the
\dispare directory to simplify this process; copy or link the Makefile
to the current directory.  By default, the generic makefile:
\begin{itemize}
\item Turns on C compiler optimization
\item Uses a FIFO queueing strategy in the Chare Kernel
\end{itemize}

Typing {\tt make PGM=}{\em filename} will use the builder's output, {\em
filename}{\tt .p}, to create an executable called {\tt filename} by
running the Chare Kernel translator and C compiler on the host machine
as specified in the generic Makefile.  On some machines the resulting
files may be called {\tt h}{\em filename} and {\tt n}{\em filename}, if
separate host and node programs are required.



If {\tt clean} is also specified on the {\tt make} command line,
intermediate files (both from the builder and the Chare Kernel
translator) will be deleted from the current directory.  The builder
produces 3 such files per event type plus 1 for the main chare.

Any compiler errors reported at this stage are a result of user errors
in the specification or code files.  Line numbers will refer to lines in
the final {\tt .p} file.

The executable file can then be run in whatever manner is appropriate to
the host machine.  A single command-line argument (in addition to the
command-line options allowed by the Chare Kernel) can be passed,
indicating the timestep at which simulation should stop.  If no value is
passed, the simulation will run ``forever,'' i.e. until the timestep
exceeds the maximum value of an integer on the target machine.

%%======================================================================
\section{Diagnostics}

Minimal diagnostics are printed by the running simulation.  Messages are
printed when {\tt StopSim} messages are processed, when fatal errors
occur that require the simulator to abort, and so forth.  At the end of
the run, the ``wall clock'' time taken by the simulation is printed, as
reported by the Chare Kernel call {\tt McTimer()}.

By defining the {\tt DEBUG} flag to the makefile (on the command line),
a simulation will be built that prints extensive diagnostic messages on
the terminal.  The messages indicate when each event chare is being
initialized, when it is being fired, when new events are scheduled and
so forth.  Be aware that these messages will clutter the screen and
interfere with output that your event code generates.  As usual, be wary
of asynchrony when interpreting the diagnostic messages.
